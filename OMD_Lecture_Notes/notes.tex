\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
%frame=tb
\lstset{frame=none ,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  stringstyle=\color{mauve},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Study Guide}
\author{Object Oriented Modeling and Design}
%\date{}                                           % Activate to display a given date or no date


%--------------------------------------------------------------------------------------------------------
%DOCUMENT START
%--------------------------------------------------------------------------------------------------------
\begin{document}
\maketitle
\lstset{language=Java}

\section*{Design Principles}

\begin{itemize}
\item SRP: Single Responsibility Principle
	\begin{itemize}
	  \item ``A class should have only one reason to change.'' (Martin)
	  \item En klass med flera ansvarsområden ger bräcklighet.
	  \item En klass utan ansvar är onödig.
	\end{itemize}
\item OCP: Open-Closed Principle
	\begin{itemize}
	  \item ``Classes should be open for extension and closed for modification.''
	  (Meyer)
	  \item Det skall vara möjligt att lägga till ny funktionalitet utan att
	  modifiera existerande kod.
	\end{itemize}
\item DIP: Dependency Inversion Principle (slides lec. 3) %TODO lec3 p9
	\begin{itemize}
	  \item ``Dependency on abstractions/ not concrete classes''
	  \item Bassically we're talking about making programs dependant on interfaces
	  instead of classes. 
	\end{itemize}
\item DRY: Don't Repeat Yourself Principle (slides lec. 4)
	\begin{itemize}
	  \item ``Every piece of knowledge must have a single, unambiguous,
	  authoritative representation within a system'' (Hunt and Thomas).
	  \item Repedative process? $\rightarrow$ automate
	  \item Repeditive function? $\rightarrow$ find applicable design pattern.
	  \item Repedative, reoccuring probems? $\rightarrow$ define a new design
	  pattern.
	  \item Repedative logic? $\rightarrow$ abstract it.
	\end{itemize}
\item ISP: Inferface Segregation Principle
\item LSP: 
\end{itemize}

\section*{Design Patterns/Mönster}

\begin{itemize}
\item Visitor
\item Command
\item Composite
\item Template/mallmetod (slides lec. 4)
\item Strategy/strategi (slides lec. 4)
\item State
\item Null Object
\end{itemize}



\section{Lecture 1}
\begin{itemize}
\item Info
	\begin{itemize}
	\item Points for \"{O}vning on Tenta!
	\end{itemize}
\item DelA: OMD objekt-modeling-design
	\begin{itemize}
	\item Classes
	\item Object
	\item Abstraction
	\item Encapsulation (Inkapsling)
	\end{itemize}
\item Graphs
	\begin{itemize}
	\item Intro
		\begin{itemize}
		\item a set of nodes and a set of bows: 
			\begin{itemize}
			\item \{ A , B , C \}
			\item \{ $<$A,B$>$ , $<$B,C$>$ , $<$C,A$>$ \}
			\end{itemize}
		\item weighted graphs
		\end{itemize}
	
	
	\item Representation
		\begin{itemize}
		\item Matrix
		\item Adjacency-list ``N\"{a}rhetslista''
		\end{itemize}
	\item Before Lab 1
		\begin{itemize}
		\item Must implement our own data structures for Graphs
		\item Make sure you understand the ADT Graph
		\item construct
		\item add Node
		\item add Bow
		\item Iterate over all nodes
		\item Iterate over all bows
		\item SOMETHING
		\end{itemize}
	\end{itemize}
\item This week
	\begin{itemize}
	\item first 6 chapters
	\item lab 1 redovisas 20/1
	\item lab 2 and \"{o}vning redovisas 25/1
	\end{itemize}
\item Example:
\end{itemize}

\begin{lstlisting}
//test
"string"
public class DiGraph{
	public Vertex firstVertex(){...}
	public void insertVertex(Vertex v){...}
	public void insertEdge(Vertex v , Vertex x , Edge e){...}
	
	public void iterateVertex(){
		Vertex v = firstVertex;
		while(v != null){
			v = v.nextVertex();
		}
	}
	
}

public class Vertex{
	public Vertex nextVertex(){...}
	public Edge firstEdge(){...}
	...
}

public class Edge{
	public Edge nextEdge(){...}
	public Vertex endpoint(){...}
	...
}
\end{lstlisting}

\section{Lecture 2}
\begin{itemize}
\item Agenda
	\begin{itemize}
	\item Grafer (depth-first-traversal)
	\item Object oriented modeling
	\end{itemize}
\item Depth-first
	\begin{itemize}
	\item Grafer (depth-first-traversal)
	\item Object oriented modeling
	\end{itemize}
\end{itemize}

\section{Lecture 3}


\subsection{principles}
\begin{itemize}
\item SRP
\item OCP
\item DIP
\item DRY
\item Theres discussion of a ``Lokalitetsprincpen''
\end{itemize}

\subsection{patterns}

\begin{itemize}
  \item Visitor
  \item Command
  \item Composite
\end{itemize}

\subsection{Pittfalls/smells}
\begin{itemize}
  \item Rigidity ``Stelhet'' - The design is difficult to modify
  \item Fragility ``Bräcklighet''- The design doesn't handle modification
  \item Immobility ``Orörlighet - Design prevents reuse and recycling
  \item Viscosity ``Seghet''? maybe ``Tröghet'' - It's more difficult to
  implement slick changes than it is to hack
\end{itemize}

\subsection{Measurement of design quality}
\begin{itemize}
  \item Coupling ``Koppling'' - The grade (level?) of dependency on other
  modulels in the system
  \item Cohesion ``Sammanhang'' - The grade (level?) of affenity/togetherness in
  the same moduel 
\end{itemize}

\subsection{Lokalitetsprincpen (Locality Principle?)}
\begin{itemize}
  \item Competition? 
  \item Delegerar arbetet till den klass som vet allt om Race:
  \item Delegerar arbetet till den klass som vet allt om Result:
\end{itemize}
\begin{lstlisting}
public class Competition {
	private ArrayList<Race> races; 
	public void computeTotal() {
		for(Race race: races ) { 
		race.computeTotal();
		} 
	}	
	...
}
\end{lstlisting}

\subsection{SRP - Enkelt ansvar}

\begin{itemize}
  \item Single Responsibility Principle
  \item ``A class should have only one reason to change.''
  \item ``A class with many responcibilities leads to fragility ``bräcklighet''
  \item A class without responsibility is uneccessary. 
  \item Delegate the responcibilities.
\end{itemize}

\begin{lstlisting}
public class Result {
	private Name name;
	private IdNumber idNumber; 
	private Time start, end;
	 
	public String fullName() {
		return name.toString(); 
	}
	
	public Time total() {
	return end.difference(start);
	}
}
\end{lstlisting}

\subsection{OCP - Open to extention/Closed to modification}
$ $
\begin{itemize}
  \item Det skall vara möjligt att lägga till ny funktionalitet utan att
  modifiera existerande kod.
\end{itemize}
\begin{lstlisting}
// --------- GOOD ---------
public interface Expr{
	public int value();
}

public class Abs implements Expr { 
	private Expr expr;
	public int value(){
  		return Math.abs(expr.value()); }
	}


// --------- BAD  ---------
public class Circle { 
	int radius;
	int x, y;
	public Circle(int radius, int x, int y) {
		this.radius = radius; this.x = x;
		this.y = y;
	}
 }
\end{lstlisting}

\section{Lecture 4}

\subsection{Design Patterns}
\begin{itemize}
\item Template method:
	\begin{itemize}
	  \item Break out the stuff that's the common.
	  \item Stick the common stuff in an abstract class.
	  \item Fill in the holes with calls of abstract methods that are implemented
	  in the subclasses.
	  \item Templates aren't very usable when the process has more than just
	  functionallity that can vairy.
	\end{itemize}
\item Strategy/strategi
	\begin{itemize}
	  \item Strategy patters are used when one wants to change how an operation is
	  preformed \textit{durring} the execution of the program.
	  \item An example of how to use a stratey pattern is below
	\end{itemize}
\item State
	\begin{itemize}
	\end{itemize}
\end{itemize}
%try to solve the thing 148-150 (sketch a UML diagram) 

\subsection{Template method ``Mallmetod''}
\begin{lstlisting}

\end{lstlisting}

\subsection{Strategy ``strategi''}
//The list is defined first
\begin{lstlisting}
public class List<T> extends ArrayList<T> { 
	private Prefix prefix = new Empty();
	public void setPrefix(Prefix prefix) {
		this.prefix = prefix;
	}
	public String toString(){
		StringBuilder builder = new StringBuilder();
		for(T t :this){
			builder.append(prefix.string());
			builder.append(t).append("\n");
		}
		return builder.toString();
	}
}

//Then the strategy is defined
public interface Prefix{
	public String string();
}

//Then the strategy classes are defined
public class Star implements Prefix{
	public String string(){
		return "*";
	}
}
public class Numbered implements Prefix{
	private int number;
	public String string(){
		number++;
		return String.valueOf(number) + " ";
	}
}
\end{lstlisting}


\section{Lecture 5}
\begin{itemize}
  \item 
\end{itemize}



\subsection{General algorithm for Lab 3}
Use the ADT ``map'' and represent the words with strings only
\begin{itemize}
  \item distance = 0
  \item markera u besökt
  \item actlevel = tom mängd
  \item lägg in u i actlevel
  \item så länge actlevel inte är tom
  \item nextlevel = tom mängd
  \item för varje nod w i actlevel
  \item om w == v
  \item returnera distance
  \item för varje granne n till w om n inte är besökt
  \item markera n besökt
  \item lägg in n i nextlevel
  \item distance++;
  \item actlevel = nextlevel returnera -1
\end{itemize} 



\begin{lstlisting}
// specific implementation Lab 3

Map<String, Set<String>>

public interface SimpleGraph
	public Set<String>
		adjacentTo(String);

\end{lstlisting}



\begin{tabular}{| c | c | c | c |}
 & syfte & medod & effekt \\
 Command & x & x & x \\
 Composit &  & & \\
 Template & x & x & x \\
 Strategy & x & x & x \\
 State & & & \\
\end{tabular}

\section{Lecture 6}

\begin{itemize}
  \item Design principles (LSP)
  \item Patterns: (Singleton, Model-View-Control, Observer)
  \item Graph-algorithms: (Shortest-path, Dijkstra)
\end{itemize}

\subsection{Singelton}
% Only one instance of an object in the system
% Singelton code lec.6



\subsection{(LSP) Liskov Substitution Principle}
% lec. 6 slides

\subsections{Graphs}

\subsubsection{Dijstras}

\begin{tabular}{| l | c | c | c | c | c | c | c |}
 & A & B & C & D & E & F & G \\ 
0 & & & & & & &\\
1 & & & & & & &\\
2 & & & & & & &\\
3 & & & & & & &\\
4 & & & & & & &\\
5 & & & & & & &\\

\end{tabular}

% Bellman Fords

\subsection{Lab 4}

% use the priority queue
% psuedo-code in slides for lec. 6
% red line in psuedo-code should use a map. 
% stick in a second node into the priority-queue if a new short is found









\end{document}
